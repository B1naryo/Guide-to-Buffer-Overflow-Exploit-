<html><head>
    <title>SANDRO</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="assets/cs/main.css">
    <script src="js/vendor/modernizr-2.8.3.min.js"></script>
  </head><body>
    <!-- Header -->
    <div id="header">
      <div class="top">
        <!-- Logo -->
        <div id="logo">
          <h2 align="center">SANDRO</h2>
        </div>
        <!-- Nav -->
        <nav id="nav">
          <nav id="nav">
            <ul>
              <li>
                <a href="index.html" id="top-link" class="skel-layers-ignoreHref"><span class="icon fa-home">INÍCIO</span></a>
              </li>
              <li>
                <a href="meusprojetos.html" id="portfolio-link" class="skel-layers-ignoreHref"><span class="icon fa-th">Buffer Overflow</span></a>
              </li>
              <li>
                <a href="tools.html" id="about-link" class="skel-layers-ignoreHref"><span class="icon fa-user">Tools</span></a>
              </li>
              <li>
                <a href="exploits.html" id="about-link" class="skel-layers-ignoreHref"><span class="icon fa-link">Exploits</span></a>
              </li>
              <li>
                <a href="videos.html" id="contact-link" class="skel-layers-ignoreHref"><span class="icon fa-envelope">Vídeos</span></a>
              </li>
            </ul>
          </nav>
        </nav>
      </div>
      <div class="bottom">
        <!-- Social Icons -->
        <ul class="icons">
          <li>
            <a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a>
          </li>
          <li>
            <a href="https://www.facebook.com/profile.php?id=100022794504085" class="icon fa-facebook"><span class="label">Facebook</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-github"><span class="label">Github</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-dribbble"><span class="label">Dribbble</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-envelope"><span class="label">Email</span></a>
          </li>
        </ul>
      </div>
    </div>
    <!-- Main -->
    <div id="main">
      <!-- Intro -->
      <!-- Portfolio -->
      <section id="portfolio" class="two">
        <div class="container">
          <header>
            <h2>Guia para Iniciantes no Desenvolvimento de Exploits de Buffer Overflow</h2>
            <h5 class="alt" align="justify">
              <br>O conteúdo a seguir apresenta um guia básico sobre o desenvolvimento de exploits</h5>
            <p></p>
            <h2>Qual é o Propósito do brainpan.exe?</h2>
            <p></p>
            <h5 align="justify">O Brainpan.exe é uma ferramenta educacional para entusiastas de segurança. É um programa não malicioso com vulnerabilidades, usado para aprender sobre tópicos como estouros de buffer.

Executei o arquivo brainpan.exe em uma máquina Windows por curiosidade para entender sua funcionalidade.&nbsp;</h5>
            <p></p>
            <p></p>
            
            <div class="container">
  <img src="images/brainpan1.png" class="img-responsive" width="1000">
</div>
              
            </div>
<h5 align="justify">É importante enfatizar que o brainpan.exe não possui intenção maliciosa. Ele opera ouvindo conexões TCP recebidas na porta 9999. A partir do meu computador Linux, tentei me conectar a essa porta, momento em que me pediu uma senha. No entanto, eu não tinha a senha correta.&nbsp;</h5>
<p></p>
            <p></p>
<div class="container">
  <img src="images/brainpan2.png" class="img-responsive" width="1000">
</div>
<p></p>
            <p></p>
          <h5 align="justify">Tentei várias senhas na tentativa de obter acesso, mas tudo o que recebi em resposta foi uma mensagem de ACESSO NEGADO, o que me deixou confuso.&nbsp;</h5>  
<p></p>
            <p></p>
<div class="container">
  <img src="images/brainpan3.png" class="img-responsive" width="1000">
</div>
<p></p>
            <h5 align="justify">Decidi investigar o que estava acontecendo no lado do Windows e descobri a partir das mensagens impressas que o servidor TCP de fato recebeu minha conexão na porta 9999 juntamente com a senha que forneci, que foi então copiada para um buffer.&nbsp;</h5> 
<p></p>
<div class="container">
  <img src="images/brainpan4.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Meu próximo passo foi localizar a senha correta. Ao analisar o binário no Linux usando uma ferramenta chamada strings, encontrei uma string codificada chamada shitstorm. A string resultante pode ser encontrada em brainpan.txt.&nbsp;</h5> 
  <p></p>
<div class="container">
  <img src="images/brainpan5.png" class="img-responsive" width="1000">
</div>

<p></p>
<h5 align="justify">
Com essa nova informação, tentei me conectar ao servidor TCP usando shitstorm como a senha, o que resultou em uma mensagem de ACESSO CONCEDIDO. No entanto, a conexão foi terminada imediatamente depois.&nbsp;</h5> 
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan6.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">
Mais uma vez, retornei para o lado do Windows para observar o que estava ocorrendo. Tornou-se evidente que toda a entrada que eu havia enviado para o servidor TCP estava sendo diretamente copiada para um buffer.&nbsp;</h5> 
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan7.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">
Como a string de entrada enviada para o servidor TCP é copiada diretamente para o buffer, torna-se imperativo testar o servidor TCP em busca de potenciais vulnerabilidades de estouro de buffer.&nbsp;</h5> 
  <p></p>
<h2>Spiking</h2>
<h2>O que é Spiking?</h2>
            <h5 class="alt" align="justify">
              <br>O Spiking, assim como o fuzzing, funciona como um método para testar protocolos de forma intensiva. A distinção chave reside em seu propósito: o spiking envolve a transmissão de dados aleatórios, muitas vezes lixo, com a intenção de sondar e potencialmente comprometer as características de segurança de um sistema. Em contraste, o fuzzing visa extrair informações significativas dos dados que envia.

No nosso caso, vamos empregar a técnica de spiking para avaliar a vulnerabilidade do buffer do brainpan.exe. Essa avaliação envolverá o uso de um "script de spiking" chamado brainpan.spk, que enviará dados arbitrários para o buffer do brainpan.exe. Para executar isso, utilizaremos a ferramenta "generic_send_tcp" no lado do Linux. Ao mesmo tempo, no lado do Windows, empregaremos o Immunity Debugger para monitorar e compreender as atividades relacionadas à memória.

O script de spiking fornecido, quando executado, envia dados para o buffer do brainpan.exe da seguinte maneira:</h5>
            <p></p>
<h6 align="left">s_readline();</h6><p></p>
<h6 align="left">s_string("shitstorm ");</h6><p></p>
<h6 align="left">s_string_variable("0");</h6><p></p>
<h5 class="alt" align="justify">
              <br>No lado do Windows, eu anexei o processo brainpan.exe ao Immunity Debugger e iniciei o processo.</h5>
            <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan8.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 class="alt" align="justify">
              <br>No lado do Linux, executei o script de spiking usando o generic_send_tcp, e o resultado resultante é mostrado abaixo.</h5>
            <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan9.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 class="alt" align="justify">
              <br>Após a execução do script, observei que em certo momento falhou em estabelecer uma conexão com o alvo. Posteriormente, investiguei o problema dentro do Immunity Debugger, onde me deparei com uma notificação de violação de acesso.</h5>
            
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan10.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 class="alt" align="justify">
              <br>Quando ocorre uma violação de acesso no Immunity Debugger, sugere-se que possa ter havido uma tentativa não autorizada de acessar ou modificar a memória, potencialmente envolvendo os componentes EIP, EBP ou ESP. Essa situação poderia apresentar uma oportunidade para investigação adicional de potenciais vulnerabilidades de estouro de buffer, mas não necessariamente confirma a presença de tais vulnerabilidades ou garante sua exploração.</h5>
            
  <p></p>
  <p></p>
<h2>Fuzzing using Python</h2>
<h2>O que é Fuzzing</h2><p></p>
<h5 align="justify">Fuzzing, também conhecido como teste de fuzz ou fuzz testing, é uma técnica automatizada de teste de software usada para descobrir vulnerabilidades, erros ou fraquezas de segurança em programas de computador, especialmente aqueles que processam entradas de usuários ou fontes externas. Aqui está uma explicação abrangente sobre o fuzzing:</h5>
<h2>Objective of Fuzzing</h2>
<h5 align="justify">O principal objetivo do fuzzing é identificar e expor vulnerabilidades de software submetendo um programa a uma grande quantidade de dados de entrada inesperados, malformados ou aleatórios. O fuzzing visa descobrir problemas como falhas, vazamentos de memória, exceções não tratadas, estouros de buffer e vulnerabilidades de segurança no software-alvo.

Para aplicar essa técnica ao servidor TCP brainpan.exe, criei um script em Python chamado brainpan_fuzzer1.py. O script envia continuamente dados para o servidor com o objetivo de sobrecarregar seu buffer.</h5>

 <p></p>
  <p></p>
<div class="container">
  <img src="images/code.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Este programa em Python envia repetidamente uma sequência de caracteres "A" até que eventualmente cause uma sobrecarga de buffer. Ao contrário do script de spiking anterior, o script em Python fornece informações sobre o número de bytes que causaram a falha do servidor TCP brainpan.exe. Após a execução do programa, de fato ocorreu uma sobrecarga de buffer, como evidenciado pela saída.</h5>
 <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan11.png" class="img-responsive" width="1000">
</div>
<p></p>
<h2>Finding the Offset</h2>
<h5 align="justify">Na seção anterior, utilizamos um script de fuzzing para identificar um tamanho aproximado em bytes no qual o processo brainpan.exe experimentou uma falha. Inicialmente, o estouro de buffer ocorreu com um tamanho de "1000 bytes". Agora, nosso objetivo é determinar o deslocamento preciso no qual o EIP (Extended Instruction Pointer) foi sobrescrito.

Para alcançar isso, criaremos um padrão único usando o módulo pattern_create.rb do Metasploit, gerando o padrão com base nos resultados obtidos do processo de fuzzing anterior.

A string gerada é uma sequência única de caracteres usada para determinar o momento exato em que a memória de um programa é alterada durante um estouro de buffer. Ao reconhecer essa string na memória do programa, é possível identificar a localização específica (deslocamento) onde informações importantes de controle do programa, como o EIP, foram sobrescritas. Essas informações são cruciais para a criação de um payload mais eficaz para um exploit de estouro de buffer.</h5>

<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan12.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Posteriormente, transmitiremos esse padrão gerado para o servidor TCP para determinar o ponto exato no qual o EIP foi sobrescrito. Para esse fim, criei outro script em Python chamado brainpan_fuzzer2.py.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code1.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Após executar esse script, ele efetivamente disparou um estouro de buffer. Posteriormente, examinei o ambiente do Windows usando o Immunity Debugger para identificar o valor preciso armazenado no registro EIP, que acabou sendo 41307241. Esse valor representa o endereço de memória específico da próxima instrução a ser executada após o buffer ser sobrescrito.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan13.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">Em seguida, vamos usar outro módulo do Metasploit chamado pattern_offset.rb para determinar o deslocamento exato. Esse cálculo de deslocamento é baseado no valor do EIP observado e no comprimento do padrão gerado anteriormente.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan14.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Como ilustrado na captura de tela acima, identificamos com sucesso o deslocamento exato do estouro de buffer, que é de 510 bytes (indicando que nosso buffer foi sobrecarregado em 510 bytes). Nosso próximo passo é sobrescrever o EIP com um valor controlado.</h5>
<p></p>
  <p></p>
<h2>Sobrescrevendo o EIP</h2>
<p></p>

<h5 align="justify">Em nosso passo anterior, conseguimos sobrecarregar o buffer, o que significa que temos controle sobre os dados que irão sobrescrever o EIP (Extended Instruction Pointer).

Para prosseguir com a sobrescrita do EIP, precisamos considerar que há 510 bytes precedendo o EIP. Portanto, enviaremos 510 bytes preenchidos com caracteres 'A' para alcançar o EIP, seguidos por 4 bytes preenchidos com caracteres 'B' para sobrescrever o EIP.

Para realizar isso, desenvolvi outro script chamado brainpan_fuzzer3.py. Este script é projetado para realizar a operação de sobrescrita.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code2.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Após executar o script, examinei a saída no Immunity Debugger. Eu observei que o EBP (Extended Base Pointer) estava preenchido com 'A's (41414141), e o EIP estava preenchido com 'B's (42424242).</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan15.png" class="img-responsive" width="1000">
</div>
<p></p>

<h5 align="justify">Agora que temos controle sobre o EIP, estamos prontos para enviar um código shell malicioso para comprometer nosso sistema-alvo e estabelecer acesso shell através do buffer brainpan.exe. No entanto, antes de executar nosso código shell sem problemas, precisamos identificar quaisquer caracteres problemáticos potenciais, conhecidos como caracteres inválidos.</h5>
              
<h2>Finding bad characters</h2>
<h5 align="justify">Ao criar um shellcode, é crucial identificar quais caracteres podem causar problemas, referidos como caracteres inválidos, e quais são seguros para uso. Para simplificar o processo de encontrar esses caracteres inválidos para nosso exploit, vamos aproveitar o mona dentro do Immunity Debugger. Primeiro, configuramos o diretório de trabalho do mona no Immunity Debugger usando o seguinte comando:</h5>
<p align="left">!mona config -set workingfolder c:\mona</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan16.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Isso define o diretório de trabalho para o mona no Immunity Debugger. Com o diretório de trabalho configurado, podemos gerar uma matriz de bytes de caracteres inválidos usando o mona com o seguinte comando:</h5>
<p align="left">!mona bytearray -cpb "\x00</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan17.png" class="img-responsive" width="1000">
</div>
<p></p>


<div class="container">
  <img src="images/brainpan18.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Em seguida, enviamos esta matriz de caracteres inválidos para o nosso servidor TCP brainpan.exe após sobrescrever o EIP. Para isso, criei outro script chamado brainpan_badchars.py. Este script incorpora a matriz de caracteres inválidos do mona no payload.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code3.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Após executar o script e inspecionar o dump do ESP (Extended Stack Pointer) no Immunity Debugger (para fazer o dump do ESP, clique com o botão direito no ESP e no menu suspenso, selecione Follow in Dump. Ele fará o dump e exibirá todos os caracteres hexadecimais que enviamos com nosso script em python), podemos claramente observar todos os caracteres inválidos enviados pelo programa em Python no Immunity Debugger:</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan19.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Nós recuperamos o conteúdo do ESP, que foi o endereço de memória 005FF910. Para verificar a presença de quaisquer caracteres indesejados específicos para nosso exploit, utilizamos o mona com o seguinte comando dentro do Immunity Debugger:
</h5>
<p align="left">!mona compare -f c:\mona\bytearray.bin -a 005FF910</p>
<h5>Mona realizou uma comparação entre a matriz de bytes gerada e o dump do ESP.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan20.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">No contexto do brainpan.exe, nenhum caractere inválido foi detectado para nosso shellcode.

Agora que identificamos os caracteres inválidos a serem evitados em nosso exploit, nosso próximo passo é encontrar o módulo adequado para nosso payload.<h5>
<h2>Finding the Correct Module</h2>
<h5 align="justify">Nosso objetivo é identificar uma DLL ou um componente similar dentro do brainpan.exe que não possua configurações de proteção de memória. Para isso, vamos utilizar a ferramenta mona, que pode ajudar a encontrar o módulo correto. Você pode usar o seguinte comando para listar todos os módulos dentro do brainpan.exe:</h5>
<p align="left">!mona modules</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan21.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Como visto na captura de tela acima, todos os arquivos DLL têm a proteção de memória ativada. No entanto, o brainpan.exe não possui proteção de memória, tornando-o a escolha ideal para o nosso módulo alvo. Nosso próximo passo envolve identificar um código de operação equivalente a JMP ESP. Para isso, vamos contar com o módulo do Metasploit chamado nasm_shell.rb.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan22.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">A partir da captura de tela acima, é evidente que o opcode que procuramos é FFE4. Para determinar o endereço de memória contendo o opcode FFE4 (JMP ESP) dentro do brainpan.exe, podemos utilizar o seguinte comando do mona:</h5>
<p align="left">!mona find -s "\xff\xe4" -m brainpan.exe</p>
  <p></p>
<div class="container">
  <img src="images/brainpan23.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">A partir da captura de tela acima, é evidente que o opcode que procuramos é FFE4. Para determinar o endereço de memória contendo o opcode FFE4 (JMP ESP) dentro do brainpan.exe, podemos utilizar o seguinte comando do mona:</h5>

  <p></p>
<div class="container">
  <img src="images/code4.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Executando o script acima, irá acionar um ponto de interrupção diretamente no Immunity Debugger, pausando o processo de execução.</h5>

  <p></p>
<div class="container">
  <img src="images/brainpan24.png" class="img-responsive" width="1000">
</div>
<p></p>

<h5 align="justify"> Como evidenciado pela captura de tela, conseguimos com sucesso acionar nosso ponto de interrupção, indicando que agora temos controle total sobre o EIP. Isso nos permite executar qualquer shellcode necessário para comprometer nossa máquina-alvo.</h5>
<p></p>
<h2>Generating shellcode and gaining access</h2>
<h5 align="justify">É hora de gerar o shellcode. Vamos usar o msfvenom para criar um payload de shell reverso. A sintaxe a ser seguida é:</h5>
<div class="container">
<img src="images/brainpan25.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Em seguida, precisamos transmitir nosso shellcode seguindo esta sequência:</h5>
<p align="left">buffer = b"A" * 510 + b"\xf3\x12\x17\x31" +  b"\x90" * 32 + shell_code</p> 
<h5 align="justify">Aqui está o que acontece: nós sobrecarregamos o buffer com 510 caracteres 'A', o que nos permite alcançar o EIP (Extended Instruction Pointer) e sobrescrevê-lo com um endereço de memória apontando para o ESP (Extended Stack Pointer), no nosso caso, é 311712F3 (\xf3\x12\x17\x31). Em seguida, inserimos 32 instruções NOP (NOP significa No Operation) para manter tamanhos de payload consistentes, seguido pelo nosso shellcode real.

Eu escrevi um script em Python chamado brainpan_exploit.py.</h5>
<div class="container">
<img src="images/code5.png" class="img-responsive" width="1000">
</div>

<h5 align="justify">Finalmente, podemos começar a ouvir a porta 4455 no lado do Linux para capturar nosso shell reverso. Agora podemos enviar nosso buffer para o servidor TCP brainpan.exe.</h5>
<div class="container">
<img src="images/brainpan26.png" class="img-responsive" width="1000">
</div>
    <h5 align="left">FERRAMENTAS UTILIZADAS:</h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.exe">brainpan.exe</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.spk">brainpan.spk</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.txt">brainpan.txt</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_badchars.py">brainpan_badchars.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer1.py">brainpan_fuzzer1.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer2.py">brainpan_fuzzer2.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer3.py">brainpan_fuzzer3.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_jmp_esp.py">brainpan_jmp_esp.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/oscp.exee">oscp.exe</a></h5>
<h5 align="justify">Como você pode ver na captura de tela acima, uma vez que o script em Python é executado, você receberá a conexão do shell reverso. Agora temos controle total sobre a máquina alvo. 😄😄😄<br>
Colocando seu Conhecimento à Prova<br>

Após obter uma compreensão sólida do desenvolvimento de exploits para vulnerabilidades de estouro de buffer, é hora de aplicar seu conhecimento examinando e testando dois executáveis distintos: oscp.exe e R-3.4.4-win.exe. Estes exercícios práticos fornecerão experiência<br> prática na identificação e exploração de vulnerabilidades de estouro de buffer.
<br>
Executável 1: oscp.exe<br>
Este executável foi intencionalmente projetado com uma vulnerabilidade específica de estouro de buffer.<br>
Sua tarefa é identificar a vulnerabilidade, desenvolver um exploit e executá-lo.<br>
Documente minuciosamente suas descobertas, incluindo os passos que você tomou e o impacto do exploit.<br>

Executável 2: R-3.4.4-win.exe<br>
R-3.4.4-win.exe é um programa de software legítimo e contém uma vulnerabilidade de estouro de buffer que você explorará.<br>
Similar ao oscp.exe, este segundo executável também contém uma vulnerabilidade de estouro de buffer, mas pode apresentar desafios e características diferentes.<br>
Seu objetivo é descobrir a vulnerabilidade, criar um exploit e executá-lo.<br>
Assim como no primeiro exercício, certifique-se de documentar seu processo minuciosamente.<br>

Antes de Começar:<br>

Considerações Legais e Éticas: Sempre assegure-se de ter autorização adequada e de estar trabalhando em um ambiente controlado ao testar esses executáveis. A exploração não autorizada de vulnerabilidades é tanto antiética quanto ilegal.<br>

Medidas de Segurança: Conduza seus testes em ambientes isolados para evitar quaisquer consequências indesejadas.<br>

Documentação: Mantenha registros detalhados de suas descobertas, incluindo a vulnerabilidade, seu código de exploit e quaisquer mitigações ou correções recomendadas.<br>

Experiência de Aprendizado: Use esses exercícios como oportunidades para aplicar o conhecimento e as técnicas que você aprendeu. Aborde-os com uma mentalidade de aprendizado e observe quaisquer desafios que você encontrar.<br>

Buscar Orientação: Se enfrentar dificuldades ou tiver dúvidas durante os exercícios, sinta-se à vontade para buscar orientação ou esclarecimentos.<br>

FELIZ HACKING 🔥</h5>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <p>
                <br>
              </p>
            </div></h5>
          </header>
        </div>
      </section>
      <!-- About Me -->
      <!-- Contact -->
    </div>
    <!-- Footer -->
    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/jquery.scrollzer.min.js"></script>
    <script src="assets/js/skel.min.js"></script>
    <script src="assets/js/util.js"></script>
    <!--[if lte IE 8]>
      <script src="assets/js/ie/respond.min.js"></script>
    <![endif]-->
    <script src="assets/js/main.js"></script>
    <div id="footer">
      <!-- Copyright -->
      <ul class="copyright">
        <li>Site desenvolvido por Sandro</li>
        <li>Contato:
          <a href="#">Facebook</a>
        </li>
      </ul>
    </div>
  

</body></html>

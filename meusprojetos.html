<html><head>
    <title>SANDRO</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="assets/cs/main.css">
    <script src="js/vendor/modernizr-2.8.3.min.js"></script>
  </head><body>
    <!-- Header -->
    <div id="header">
      <div class="top">
        <!-- Logo -->
        <div id="logo">
          <h2 align="center">SANDRO</h2>
        </div>
        <!-- Nav -->
        <nav id="nav">
          <nav id="nav">
            <ul>
              <li>
                <a href="index.html" id="top-link" class="skel-layers-ignoreHref"><span class="icon fa-home">IN√çCIO</span></a>
              </li>
              <li>
                <a href="meusprojetos.html" id="portfolio-link" class="skel-layers-ignoreHref"><span class="icon fa-th">Buffer Overflow</span></a>
              </li>
              <li>
                <a href="tools.html" id="about-link" class="skel-layers-ignoreHref"><span class="icon fa-user">Tools</span></a>
              </li>
              <li>
                <a href="exploits.html" id="about-link" class="skel-layers-ignoreHref"><span class="icon fa-link">Exploits</span></a>
              </li>
              <li>
                <a href="videos.html" id="contact-link" class="skel-layers-ignoreHref"><span class="icon fa-envelope">V√≠deos</span></a>
              </li>
            </ul>
          </nav>
        </nav>
      </div>
      <div class="bottom">
        <!-- Social Icons -->
        <ul class="icons">
          <li>
            <a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a>
          </li>
          <li>
            <a href="https://www.facebook.com/profile.php?id=100022794504085" class="icon fa-facebook"><span class="label">Facebook</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-github"><span class="label">Github</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-dribbble"><span class="label">Dribbble</span></a>
          </li>
          <li>
            <a href="#" class="icon fa-envelope"><span class="label">Email</span></a>
          </li>
        </ul>
      </div>
    </div>
    <!-- Main -->
    <div id="main">
      <!-- Intro -->
      <!-- Portfolio -->
      <section id="portfolio" class="two">
        <div class="container">
          <header>
            <h2>Guia para Iniciantes no Desenvolvimento de Exploits de Buffer Overflow</h2>
            <h5 class="alt" align="justify">
              <br>O conte√∫do a seguir apresenta um guia b√°sico sobre o desenvolvimento de exploits</h5>
            <p></p>
            <h2>Qual √© o Prop√≥sito do brainpan.exe?</h2>
            <p></p>
            <h5 align="justify">O Brainpan.exe √© uma ferramenta educacional para entusiastas de seguran√ßa. √â um programa n√£o malicioso com vulnerabilidades, usado para aprender sobre t√≥picos como estouros de buffer.

Executei o arquivo brainpan.exe em uma m√°quina Windows por curiosidade para entender sua funcionalidade.&nbsp;</h5>
            <p></p>
            <p></p>
            
            <div class="container">
  <img src="images/brainpan1.png" class="img-responsive" width="1000">
</div>
              
            </div>
<h5 align="justify">√â importante enfatizar que o brainpan.exe n√£o possui inten√ß√£o maliciosa. Ele opera ouvindo conex√µes TCP recebidas na porta 9999. A partir do meu computador Linux, tentei me conectar a essa porta, momento em que me pediu uma senha. No entanto, eu n√£o tinha a senha correta.&nbsp;</h5>
<p></p>
            <p></p>
<div class="container">
  <img src="images/brainpan2.png" class="img-responsive" width="1000">
</div>
<p></p>
            <p></p>
          <h5 align="justify">Tentei v√°rias senhas na tentativa de obter acesso, mas tudo o que recebi em resposta foi uma mensagem de ACESSO NEGADO, o que me deixou confuso.&nbsp;</h5>  
<p></p>
            <p></p>
<div class="container">
  <img src="images/brainpan3.png" class="img-responsive" width="1000">
</div>
<p></p>
            <h5 align="justify">Decidi investigar o que estava acontecendo no lado do Windows e descobri a partir das mensagens impressas que o servidor TCP de fato recebeu minha conex√£o na porta 9999 juntamente com a senha que forneci, que foi ent√£o copiada para um buffer.&nbsp;</h5> 
<p></p>
<div class="container">
  <img src="images/brainpan4.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Meu pr√≥ximo passo foi localizar a senha correta. Ao analisar o bin√°rio no Linux usando uma ferramenta chamada strings, encontrei uma string codificada chamada shitstorm. A string resultante pode ser encontrada em brainpan.txt.&nbsp;</h5> 
  <p></p>
<div class="container">
  <img src="images/brainpan5.png" class="img-responsive" width="1000">
</div>

<p></p>
<h5 align="justify">
Com essa nova informa√ß√£o, tentei me conectar ao servidor TCP usando shitstorm como a senha, o que resultou em uma mensagem de ACESSO CONCEDIDO. No entanto, a conex√£o foi terminada imediatamente depois.&nbsp;</h5> 
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan6.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">
Mais uma vez, retornei para o lado do Windows para observar o que estava ocorrendo. Tornou-se evidente que toda a entrada que eu havia enviado para o servidor TCP estava sendo diretamente copiada para um buffer.&nbsp;</h5> 
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan7.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">
Como a string de entrada enviada para o servidor TCP √© copiada diretamente para o buffer, torna-se imperativo testar o servidor TCP em busca de potenciais vulnerabilidades de estouro de buffer.&nbsp;</h5> 
  <p></p>
<h2>Spiking</h2>
<h2>O que √© Spiking?</h2>
            <h5 class="alt" align="justify">
              <br>O Spiking, assim como o fuzzing, funciona como um m√©todo para testar protocolos de forma intensiva. A distin√ß√£o chave reside em seu prop√≥sito: o spiking envolve a transmiss√£o de dados aleat√≥rios, muitas vezes lixo, com a inten√ß√£o de sondar e potencialmente comprometer as caracter√≠sticas de seguran√ßa de um sistema. Em contraste, o fuzzing visa extrair informa√ß√µes significativas dos dados que envia.

No nosso caso, vamos empregar a t√©cnica de spiking para avaliar a vulnerabilidade do buffer do brainpan.exe. Essa avalia√ß√£o envolver√° o uso de um "script de spiking" chamado brainpan.spk, que enviar√° dados arbitr√°rios para o buffer do brainpan.exe. Para executar isso, utilizaremos a ferramenta "generic_send_tcp" no lado do Linux. Ao mesmo tempo, no lado do Windows, empregaremos o Immunity Debugger para monitorar e compreender as atividades relacionadas √† mem√≥ria.

O script de spiking fornecido, quando executado, envia dados para o buffer do brainpan.exe da seguinte maneira:</h5>
            <p></p>
<h6 align="left">s_readline();</h6><p></p>
<h6 align="left">s_string("shitstorm ");</h6><p></p>
<h6 align="left">s_string_variable("0");</h6><p></p>
<h5 class="alt" align="justify">
              <br>No lado do Windows, eu anexei o processo brainpan.exe ao Immunity Debugger e iniciei o processo.</h5>
            <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan8.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 class="alt" align="justify">
              <br>No lado do Linux, executei o script de spiking usando o generic_send_tcp, e o resultado resultante √© mostrado abaixo.</h5>
            <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan9.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 class="alt" align="justify">
              <br>Ap√≥s a execu√ß√£o do script, observei que em certo momento falhou em estabelecer uma conex√£o com o alvo. Posteriormente, investiguei o problema dentro do Immunity Debugger, onde me deparei com uma notifica√ß√£o de viola√ß√£o de acesso.</h5>
            
  <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan10.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 class="alt" align="justify">
              <br>Quando ocorre uma viola√ß√£o de acesso no Immunity Debugger, sugere-se que possa ter havido uma tentativa n√£o autorizada de acessar ou modificar a mem√≥ria, potencialmente envolvendo os componentes EIP, EBP ou ESP. Essa situa√ß√£o poderia apresentar uma oportunidade para investiga√ß√£o adicional de potenciais vulnerabilidades de estouro de buffer, mas n√£o necessariamente confirma a presen√ßa de tais vulnerabilidades ou garante sua explora√ß√£o.</h5>
            
  <p></p>
  <p></p>
<h2>Fuzzing using Python</h2>
<h2>O que √© Fuzzing</h2><p></p>
<h5 align="justify">Fuzzing, tamb√©m conhecido como teste de fuzz ou fuzz testing, √© uma t√©cnica automatizada de teste de software usada para descobrir vulnerabilidades, erros ou fraquezas de seguran√ßa em programas de computador, especialmente aqueles que processam entradas de usu√°rios ou fontes externas. Aqui est√° uma explica√ß√£o abrangente sobre o fuzzing:</h5>
<h2>Objective of Fuzzing</h2>
<h5 align="justify">O principal objetivo do fuzzing √© identificar e expor vulnerabilidades de software submetendo um programa a uma grande quantidade de dados de entrada inesperados, malformados ou aleat√≥rios. O fuzzing visa descobrir problemas como falhas, vazamentos de mem√≥ria, exce√ß√µes n√£o tratadas, estouros de buffer e vulnerabilidades de seguran√ßa no software-alvo.

Para aplicar essa t√©cnica ao servidor TCP brainpan.exe, criei um script em Python chamado brainpan_fuzzer1.py. O script envia continuamente dados para o servidor com o objetivo de sobrecarregar seu buffer.</h5>

 <p></p>
  <p></p>
<div class="container">
  <img src="images/code.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Este programa em Python envia repetidamente uma sequ√™ncia de caracteres "A" at√© que eventualmente cause uma sobrecarga de buffer. Ao contr√°rio do script de spiking anterior, o script em Python fornece informa√ß√µes sobre o n√∫mero de bytes que causaram a falha do servidor TCP brainpan.exe. Ap√≥s a execu√ß√£o do programa, de fato ocorreu uma sobrecarga de buffer, como evidenciado pela sa√≠da.</h5>
 <p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan11.png" class="img-responsive" width="1000">
</div>
<p></p>
<h2>Finding the Offset</h2>
<h5 align="justify">Na se√ß√£o anterior, utilizamos um script de fuzzing para identificar um tamanho aproximado em bytes no qual o processo brainpan.exe experimentou uma falha. Inicialmente, o estouro de buffer ocorreu com um tamanho de "1000 bytes". Agora, nosso objetivo √© determinar o deslocamento preciso no qual o EIP (Extended Instruction Pointer) foi sobrescrito.

Para alcan√ßar isso, criaremos um padr√£o √∫nico usando o m√≥dulo pattern_create.rb do Metasploit, gerando o padr√£o com base nos resultados obtidos do processo de fuzzing anterior.

A string gerada √© uma sequ√™ncia √∫nica de caracteres usada para determinar o momento exato em que a mem√≥ria de um programa √© alterada durante um estouro de buffer. Ao reconhecer essa string na mem√≥ria do programa, √© poss√≠vel identificar a localiza√ß√£o espec√≠fica (deslocamento) onde informa√ß√µes importantes de controle do programa, como o EIP, foram sobrescritas. Essas informa√ß√µes s√£o cruciais para a cria√ß√£o de um payload mais eficaz para um exploit de estouro de buffer.</h5>

<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan12.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Posteriormente, transmitiremos esse padr√£o gerado para o servidor TCP para determinar o ponto exato no qual o EIP foi sobrescrito. Para esse fim, criei outro script em Python chamado brainpan_fuzzer2.py.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code1.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Ap√≥s executar esse script, ele efetivamente disparou um estouro de buffer. Posteriormente, examinei o ambiente do Windows usando o Immunity Debugger para identificar o valor preciso armazenado no registro EIP, que acabou sendo 41307241. Esse valor representa o endere√ßo de mem√≥ria espec√≠fico da pr√≥xima instru√ß√£o a ser executada ap√≥s o buffer ser sobrescrito.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan13.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">Em seguida, vamos usar outro m√≥dulo do Metasploit chamado pattern_offset.rb para determinar o deslocamento exato. Esse c√°lculo de deslocamento √© baseado no valor do EIP observado e no comprimento do padr√£o gerado anteriormente.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan14.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Como ilustrado na captura de tela acima, identificamos com sucesso o deslocamento exato do estouro de buffer, que √© de 510 bytes (indicando que nosso buffer foi sobrecarregado em 510 bytes). Nosso pr√≥ximo passo √© sobrescrever o EIP com um valor controlado.</h5>
<p></p>
  <p></p>
<h2>Sobrescrevendo o EIP</h2>
<p></p>

<h5 align="justify">Em nosso passo anterior, conseguimos sobrecarregar o buffer, o que significa que temos controle sobre os dados que ir√£o sobrescrever o EIP (Extended Instruction Pointer).

Para prosseguir com a sobrescrita do EIP, precisamos considerar que h√° 510 bytes precedendo o EIP. Portanto, enviaremos 510 bytes preenchidos com caracteres 'A' para alcan√ßar o EIP, seguidos por 4 bytes preenchidos com caracteres 'B' para sobrescrever o EIP.

Para realizar isso, desenvolvi outro script chamado brainpan_fuzzer3.py. Este script √© projetado para realizar a opera√ß√£o de sobrescrita.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code2.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Ap√≥s executar o script, examinei a sa√≠da no Immunity Debugger. Eu observei que o EBP (Extended Base Pointer) estava preenchido com 'A's (41414141), e o EIP estava preenchido com 'B's (42424242).</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan15.png" class="img-responsive" width="1000">
</div>
<p></p>

<h5 align="justify">Agora que temos controle sobre o EIP, estamos prontos para enviar um c√≥digo shell malicioso para comprometer nosso sistema-alvo e estabelecer acesso shell atrav√©s do buffer brainpan.exe. No entanto, antes de executar nosso c√≥digo shell sem problemas, precisamos identificar quaisquer caracteres problem√°ticos potenciais, conhecidos como caracteres inv√°lidos.</h5>
              
<h2>Finding bad characters</h2>
<h5 align="justify">Ao criar um shellcode, √© crucial identificar quais caracteres podem causar problemas, referidos como caracteres inv√°lidos, e quais s√£o seguros para uso. Para simplificar o processo de encontrar esses caracteres inv√°lidos para nosso exploit, vamos aproveitar o mona dentro do Immunity Debugger. Primeiro, configuramos o diret√≥rio de trabalho do mona no Immunity Debugger usando o seguinte comando:</h5>
<p align="left">!mona config -set workingfolder c:\mona</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan16.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Isso define o diret√≥rio de trabalho para o mona no Immunity Debugger. Com o diret√≥rio de trabalho configurado, podemos gerar uma matriz de bytes de caracteres inv√°lidos usando o mona com o seguinte comando:</h5>
<p align="left">!mona bytearray -cpb "\x00</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan17.png" class="img-responsive" width="1000">
</div>
<p></p>


<div class="container">
  <img src="images/brainpan18.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Em seguida, enviamos esta matriz de caracteres inv√°lidos para o nosso servidor TCP brainpan.exe ap√≥s sobrescrever o EIP. Para isso, criei outro script chamado brainpan_badchars.py. Este script incorpora a matriz de caracteres inv√°lidos do mona no payload.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/code3.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Ap√≥s executar o script e inspecionar o dump do ESP (Extended Stack Pointer) no Immunity Debugger (para fazer o dump do ESP, clique com o bot√£o direito no ESP e no menu suspenso, selecione Follow in Dump. Ele far√° o dump e exibir√° todos os caracteres hexadecimais que enviamos com nosso script em python), podemos claramente observar todos os caracteres inv√°lidos enviados pelo programa em Python no Immunity Debugger:</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan19.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">N√≥s recuperamos o conte√∫do do ESP, que foi o endere√ßo de mem√≥ria 005FF910. Para verificar a presen√ßa de quaisquer caracteres indesejados espec√≠ficos para nosso exploit, utilizamos o mona com o seguinte comando dentro do Immunity Debugger:
</h5>
<p align="left">!mona compare -f c:\mona\bytearray.bin -a 005FF910</p>
<h5>Mona realizou uma compara√ß√£o entre a matriz de bytes gerada e o dump do ESP.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan20.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">No contexto do brainpan.exe, nenhum caractere inv√°lido foi detectado para nosso shellcode.

Agora que identificamos os caracteres inv√°lidos a serem evitados em nosso exploit, nosso pr√≥ximo passo √© encontrar o m√≥dulo adequado para nosso payload.<h5>
<h2>Finding the Correct Module</h2>
<h5 align="justify">Nosso objetivo √© identificar uma DLL ou um componente similar dentro do brainpan.exe que n√£o possua configura√ß√µes de prote√ß√£o de mem√≥ria. Para isso, vamos utilizar a ferramenta mona, que pode ajudar a encontrar o m√≥dulo correto. Voc√™ pode usar o seguinte comando para listar todos os m√≥dulos dentro do brainpan.exe:</h5>
<p align="left">!mona modules</p>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan21.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Como visto na captura de tela acima, todos os arquivos DLL t√™m a prote√ß√£o de mem√≥ria ativada. No entanto, o brainpan.exe n√£o possui prote√ß√£o de mem√≥ria, tornando-o a escolha ideal para o nosso m√≥dulo alvo. Nosso pr√≥ximo passo envolve identificar um c√≥digo de opera√ß√£o equivalente a JMP ESP. Para isso, vamos contar com o m√≥dulo do Metasploit chamado nasm_shell.rb.</h5>
<p></p>
  <p></p>
<div class="container">
  <img src="images/brainpan22.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">A partir da captura de tela acima, √© evidente que o opcode que procuramos √© FFE4. Para determinar o endere√ßo de mem√≥ria contendo o opcode FFE4 (JMP ESP) dentro do brainpan.exe, podemos utilizar o seguinte comando do mona:</h5>
<p align="left">!mona find -s "\xff\xe4" -m brainpan.exe</p>
  <p></p>
<div class="container">
  <img src="images/brainpan23.png" class="img-responsive" width="1000">
</div>
<p></p>
<p></p>
<h5 align="justify">A partir da captura de tela acima, √© evidente que o opcode que procuramos √© FFE4. Para determinar o endere√ßo de mem√≥ria contendo o opcode FFE4 (JMP ESP) dentro do brainpan.exe, podemos utilizar o seguinte comando do mona:</h5>

  <p></p>
<div class="container">
  <img src="images/code4.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Executando o script acima, ir√° acionar um ponto de interrup√ß√£o diretamente no Immunity Debugger, pausando o processo de execu√ß√£o.</h5>

  <p></p>
<div class="container">
  <img src="images/brainpan24.png" class="img-responsive" width="1000">
</div>
<p></p>

<h5 align="justify"> Como evidenciado pela captura de tela, conseguimos com sucesso acionar nosso ponto de interrup√ß√£o, indicando que agora temos controle total sobre o EIP. Isso nos permite executar qualquer shellcode necess√°rio para comprometer nossa m√°quina-alvo.</h5>
<p></p>
<h2>Generating shellcode and gaining access</h2>
<h5 align="justify">√â hora de gerar o shellcode. Vamos usar o msfvenom para criar um payload de shell reverso. A sintaxe a ser seguida √©:</h5>
<div class="container">
<img src="images/brainpan25.png" class="img-responsive" width="1000">
</div>
<p></p>
<h5 align="justify">Em seguida, precisamos transmitir nosso shellcode seguindo esta sequ√™ncia:</h5>
<p align="left">buffer = b"A" * 510 + b"\xf3\x12\x17\x31" +  b"\x90" * 32 + shell_code</p> 
<h5 align="justify">Aqui est√° o que acontece: n√≥s sobrecarregamos o buffer com 510 caracteres 'A', o que nos permite alcan√ßar o EIP (Extended Instruction Pointer) e sobrescrev√™-lo com um endere√ßo de mem√≥ria apontando para o ESP (Extended Stack Pointer), no nosso caso, √© 311712F3 (\xf3\x12\x17\x31). Em seguida, inserimos 32 instru√ß√µes NOP (NOP significa No Operation) para manter tamanhos de payload consistentes, seguido pelo nosso shellcode real.

Eu escrevi um script em Python chamado brainpan_exploit.py.</h5>
<div class="container">
<img src="images/code5.png" class="img-responsive" width="1000">
</div>

<h5 align="justify">Finalmente, podemos come√ßar a ouvir a porta 4455 no lado do Linux para capturar nosso shell reverso. Agora podemos enviar nosso buffer para o servidor TCP brainpan.exe.</h5>
<div class="container">
<img src="images/brainpan26.png" class="img-responsive" width="1000">
</div>
    <h5 align="left">FERRAMENTAS UTILIZADAS:</h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.exe">brainpan.exe</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.spk">brainpan.spk</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan.txt">brainpan.txt</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_badchars.py">brainpan_badchars.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer1.py">brainpan_fuzzer1.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer2.py">brainpan_fuzzer2.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_fuzzer3.py">brainpan_fuzzer3.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/brainpan_jmp_esp.py">brainpan_jmp_esp.py</a></h5>
    <h5 align="left"><a href="https://github.com/B1naryo/Guide-to-Buffer-Overflow-Exploit-/blob/main/resources/oscp.exee">oscp.exe</a></h5>
<h5 align="justify">Como voc√™ pode ver na captura de tela acima, uma vez que o script em Python √© executado, voc√™ receber√° a conex√£o do shell reverso. Agora temos controle total sobre a m√°quina alvo. üòÑüòÑüòÑ<br>
Colocando seu Conhecimento √† Prova<br>

Ap√≥s obter uma compreens√£o s√≥lida do desenvolvimento de exploits para vulnerabilidades de estouro de buffer, √© hora de aplicar seu conhecimento examinando e testando dois execut√°veis distintos: oscp.exe e R-3.4.4-win.exe. Estes exerc√≠cios pr√°ticos fornecer√£o experi√™ncia<br> pr√°tica na identifica√ß√£o e explora√ß√£o de vulnerabilidades de estouro de buffer.
<br>
Execut√°vel 1: oscp.exe<br>
Este execut√°vel foi intencionalmente projetado com uma vulnerabilidade espec√≠fica de estouro de buffer.<br>
Sua tarefa √© identificar a vulnerabilidade, desenvolver um exploit e execut√°-lo.<br>
Documente minuciosamente suas descobertas, incluindo os passos que voc√™ tomou e o impacto do exploit.<br>

Execut√°vel 2: R-3.4.4-win.exe<br>
R-3.4.4-win.exe √© um programa de software leg√≠timo e cont√©m uma vulnerabilidade de estouro de buffer que voc√™ explorar√°.<br>
Similar ao oscp.exe, este segundo execut√°vel tamb√©m cont√©m uma vulnerabilidade de estouro de buffer, mas pode apresentar desafios e caracter√≠sticas diferentes.<br>
Seu objetivo √© descobrir a vulnerabilidade, criar um exploit e execut√°-lo.<br>
Assim como no primeiro exerc√≠cio, certifique-se de documentar seu processo minuciosamente.<br>

Antes de Come√ßar:<br>

Considera√ß√µes Legais e √âticas: Sempre assegure-se de ter autoriza√ß√£o adequada e de estar trabalhando em um ambiente controlado ao testar esses execut√°veis. A explora√ß√£o n√£o autorizada de vulnerabilidades √© tanto anti√©tica quanto ilegal.<br>

Medidas de Seguran√ßa: Conduza seus testes em ambientes isolados para evitar quaisquer consequ√™ncias indesejadas.<br>

Documenta√ß√£o: Mantenha registros detalhados de suas descobertas, incluindo a vulnerabilidade, seu c√≥digo de exploit e quaisquer mitiga√ß√µes ou corre√ß√µes recomendadas.<br>

Experi√™ncia de Aprendizado: Use esses exerc√≠cios como oportunidades para aplicar o conhecimento e as t√©cnicas que voc√™ aprendeu. Aborde-os com uma mentalidade de aprendizado e observe quaisquer desafios que voc√™ encontrar.<br>

Buscar Orienta√ß√£o: Se enfrentar dificuldades ou tiver d√∫vidas durante os exerc√≠cios, sinta-se √† vontade para buscar orienta√ß√£o ou esclarecimentos.<br>

FELIZ HACKING üî•</h5>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>
              <p>
                <br>
              </p>
            </div></h5>
          </header>
        </div>
      </section>
      <!-- About Me -->
      <!-- Contact -->
    </div>
    <!-- Footer -->
    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/jquery.scrollzer.min.js"></script>
    <script src="assets/js/skel.min.js"></script>
    <script src="assets/js/util.js"></script>
    <!--[if lte IE 8]>
      <script src="assets/js/ie/respond.min.js"></script>
    <![endif]-->
    <script src="assets/js/main.js"></script>
    <div id="footer">
      <!-- Copyright -->
      <ul class="copyright">
        <li>Site desenvolvido por Sandro</li>
        <li>Contato:
          <a href="#">Facebook</a>
        </li>
      </ul>
    </div>
  

</body></html>
